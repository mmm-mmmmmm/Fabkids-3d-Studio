<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7J1T86XVM0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-7J1T86XVM0');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>Fabkids 3D Studio - Kid's Voxel Creator !</title>
    <meta name="description" content="Free 3D voxel builder for kids! Create gardens, castles, spaceships instantly.">
    
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #4D96FF;
            --primary-dark: #2962ff;
            --accent: #FFD93D;
            --danger: #FF6B6B;
            --success: #6BCB77;
            --purple: #A29BFE;
            --text: #2D3748;
            --text-light: #718096;
            --bg-panel: rgba(255, 255, 255, 0.96);
            --bg-card: #ffffff;
            --nav-height: 60px;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }

        body {
            margin: 0; padding: 0; overflow: hidden;
            font-family: 'Fredoka', sans-serif;
            background: linear-gradient(135deg, #E0F7FA 0%, #80DEEA 100%);
            color: var(--text);
            user-select: none;
        }

        #canvas-container { 
            width: 100vw; height: 100vh; display: block; 
            position: fixed; top: 0; left: 0; z-index: 0;
        }

        /* =========================================
           UNIVERSAL TOP BAR
           ========================================= */
        .top-nav {
            position: fixed;
            top: 0; left: 0; right: 0;
            height: var(--nav-height);
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px;
            z-index: 500;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            border-bottom: 1px solid rgba(255,255,255,0.5);
        }

        .brand-container { display: flex; align-items: center; gap: 10px; }
        .brand-logo {
            font-size: 24px; background: #EBF8FF; width: 40px; height: 40px;
            border-radius: 10px; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .brand-name { font-size: 20px; font-weight: 700; color: var(--primary); letter-spacing: 0.5px; text-shadow: 2px 2px 0px #fff; }

        .mobile-header-actions { display: none; }

        /* =========================================
           DESKTOP PANELS
           ========================================= */
        .glass-panel {
            position: absolute; top: 80px; 
            background: var(--bg-panel);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            padding: 24px; border-radius: 28px; border: 4px solid #fff;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15), 0 4px 10px rgba(0,0,0,0.05);
            pointer-events: auto; overflow-y: auto; scrollbar-width: none;
            max-height: calc(100vh - 100px);
            display: flex; flex-direction: column; gap: 20px;
            z-index: 10;
        }
        .glass-panel::-webkit-scrollbar { display: none; }

        #left-panel { left: 20px; width: 300px; }
        #right-panel { right: 20px; width: 340px; }

        .header { text-align: center; margin-bottom: -5px; }
        h2 { font-size: 16px; color: var(--text-light); margin: 0; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }

        .card {
            background: var(--bg-card); border-radius: 24px; padding: 18px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.02); border: 2px solid #F7FAFC;
            transition: border-color 0.2s; flex-shrink: 0;
        }
        .card:hover { border-color: #EDF2F7; }
        
        .card-title {
            font-size: 13px; text-transform: uppercase; letter-spacing: 1.5px;
            color: var(--text-light); font-weight: 800; margin-bottom: 14px;
            display: flex; align-items: center; gap: 8px;
        }

        /* --- UI COMPONENTS --- */
        .mode-switch-container { display: flex; background: #E2E8F0; padding: 4px; border-radius: 14px; margin-bottom: 10px; }
        .mode-btn { flex: 1; padding: 10px; border:none; background:transparent; font-family:'Fredoka'; font-weight:600; color:var(--text-light); cursor:pointer; border-radius:12px; transition:all 0.2s; font-size: 14px; white-space: nowrap;}
        .mode-btn.active { background: #fff; color: var(--primary); box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
        .mode-btn#btnViewMode.active { color: var(--success); }

        .shape-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 10px; }
        .shape-btn { padding: 8px 4px; border-radius: 12px; background: #EDF2F7; color: var(--text-light); font-size: 11px; font-weight: 600; border: 2px solid transparent; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 60px; transition:all 0.2s; }
        .shape-btn.active { background: var(--accent); color: #333; box-shadow: 0 4px 8px rgba(255, 217, 61, 0.4); border-color: #F5C32E; transform: translateY(-2px); }
        .shape-icon { font-size: 20px; margin-bottom: 2px; }

        .slider-row { display: flex; align-items: center; gap: 8px; margin-top: 8px; background: #FFF8E1; padding: 8px 12px; border-radius: 12px; border: 1px dashed #F5C32E; }
        .slider-btn { width: 28px; height: 28px; border-radius: 50%; border: none; background: #F5C32E; color: #333; font-weight: bold; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; padding-bottom: 2px;}
        input[type=range] { flex: 1; height: 8px; background: #e2e8f0; border-radius: 5px; -webkit-appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--primary); cursor: pointer; border: 3px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .math-display { font-size: 15px; font-weight: 700; color: #d9a404; text-align: center; width: 100%; display: block; margin-bottom: 10px; background: #FFF8E1; padding: 10px; border-radius: 12px; border: 2px solid #F5C32E; }
        .slider-label { font-size: 12px; font-weight: bold; color: #888; width: 45px; text-transform: uppercase; }

        .row { display: flex; gap: 8px; align-items: center; }
        .tool-btn { flex: 1; padding: 12px; border-radius: 12px; background: #EDF2F7; color: var(--text); border: none; cursor: pointer; font-family:'Fredoka'; font-weight:600; display:flex; justify-content:center; gap:5px; font-size:13px; transition:all 0.1s;}
        .tool-btn.active { background: var(--primary); color: white; }
        .tool-btn#eraserBtn.active { background: var(--danger); }
        .tool-btn#mirrorXBtn.active, .tool-btn#mirrorZBtn.active { background: var(--purple); color:white; }
        
        .palette-box { background: #F0F4F8; border-radius: 16px; padding: 12px; border: 2px solid #E2E8F0; }
        .color-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; }
        .swatch { width:100%; aspect-ratio:1; border-radius:50%; border:3px solid #fff; cursor:pointer; box-shadow:0 3px 6px rgba(0,0,0,0.1); transition:transform 0.2s; }
        .swatch.active { transform:scale(1.15); border-color:#333; z-index:10; }
        .swatch.rainbow { background: conic-gradient(red, yellow, lime, aqua, blue, magenta, red); }

        .layer-controls-box { background: #EBF8FF; border: 2px solid #BEE3F8; border-radius: 16px; padding: 12px; margin-top: 15px; display: flex; flex-direction: column; gap: 10px; }
        .layer-header { display: flex; justify-content: space-between; align-items: center; }
        .layer-title-group { display: flex; align-items: center; gap: 8px; }
        .layer-badge { background: var(--primary); color: white; font-weight: 800; font-size: 14px; padding: 2px 8px; border-radius: 6px; min-width: 28px; text-align: center; box-shadow: 0 2px 4px rgba(77, 150, 255, 0.3); }
        .layer-text { font-size: 12px; font-weight: 700; color: #2B6CB0; text-transform: uppercase; }
        .ghost-toggle { background: white; border: 1px solid #CBD5E0; padding: 4px 8px; border-radius: 8px; font-size: 11px; font-weight: 600; color: var(--text-light); display: flex; align-items: center; gap: 6px; cursor: pointer; }
        .layer-slider-row { display: flex; align-items: center; gap: 8px; }
        .layer-btn { width: 36px; height: 36px; border-radius: 8px; border: 2px solid #E2E8F0; background: white; color: var(--primary); font-size: 12px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.1s; box-shadow: 0 2px 0 #E2E8F0; }
        input.layer-range { flex: 1; height: 8px; background: #BEE3F8; border-radius: 4px; -webkit-appearance: none; cursor: pointer; border: none; }
        input.layer-range::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--primary); border: 3px solid #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }

        #shapeControls { overflow: hidden; transition: max-height 0.3s ease; max-height: 0; margin-top: 5px; }
        #shapeControls.open { max-height: 350px; }
        
        /* World Panel Stuff */
        .grid-select-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        .grid-option { background: #F8FAFC; border: 2px solid #EDF2F7; border-radius: 16px; padding: 8px 4px; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 6px; transition: all 0.2s; position: relative; overflow: hidden;}
        .grid-option.active { background: #EBF8FF; border-color: var(--primary); box-shadow: 0 4px 10px rgba(77, 150, 255, 0.2); }
        .grid-preview { width: 36px; height: 36px; border-radius: 8px; background-color: #fff; border: 2px solid #CBD5E0; opacity: 0.7; }
        #sizeSmallBtn .grid-preview { background-image: linear-gradient(#E2E8F0 1px, transparent 1px), linear-gradient(90deg, #E2E8F0 1px, transparent 1px); background-size: 12px 12px; }
        #sizeMedBtn .grid-preview { background-image: linear-gradient(#E2E8F0 1px, transparent 1px), linear-gradient(90deg, #E2E8F0 1px, transparent 1px); background-size: 8px 8px; }
        #sizeBigBtn .grid-preview { background-image: linear-gradient(#E2E8F0 1px, transparent 1px), linear-gradient(90deg, #E2E8F0 1px, transparent 1px); background-size: 4px 4px; }
        .grid-label { font-size: 11px; font-weight: 700; color: var(--text-light); }
        .grid-option.active .grid-label { color: var(--primary); }

        .cam-pad { background: #1e293b; border-radius: 20px; padding: 16px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 12px; border-bottom: 4px solid #0f172a; }
        .cam-top-row { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
        .btn-circle { width: 44px; height: 44px; border-radius: 50%; border: none; background: #334155; color: #e2e8f0; font-size: 20px; cursor: pointer; box-shadow: 0 4px 0 #0f172a; display: flex; align-items: center; justify-content: center; }
        .btn-home { flex: 1; height: 36px; border-radius: 18px; background: var(--primary); box-shadow: 0 4px 0 #1e40af; font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; color:white; border:none; cursor:pointer;}
        .zoom-rocker { background: #0f172a; border-radius: 12px; padding: 4px; display: flex; gap: 2px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); }
        .rocker-side { flex: 1; background: #334155; border: none; height: 32px; color: #e2e8f0; font-size: 14px; font-weight: bold; cursor: pointer; transition: background 0.1s; display: flex; align-items: center; justify-content: center; gap: 6px; }
        .rocker-side:first-child { border-radius: 8px 4px 4px 8px; border-right: 1px solid #1e293b; }
        .rocker-side:last-child { border-radius: 4px 8px 8px 4px; border-left: 1px solid #475569; }

        .hero-btn { width: 100%; padding: 14px; border: none; border-radius: 16px; font-family: 'Fredoka'; font-size: 16px; font-weight: 700; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px; margin-top:5px;}
        .btn-save { background: linear-gradient(to bottom, #6BCB77, #4CAF50); box-shadow: 0 5px 0 #388E3C; border-top: 1px solid rgba(255,255,255,0.4); }
        .btn-clear { background: #FFF5F5; color: var(--danger); border: 2px dashed #FEB2B2; box-shadow: none; font-size: 14px; }
        
        .info-hud { background: rgba(45, 55, 72, 0.95); border-radius: 16px; padding: 14px 16px; font-size: 13px; color: #E2E8F0; line-height: 1.7; position: absolute; bottom: 20px; left: 20px; width: 280px; pointer-events: none; z-index: 100; }
        .info-key { color: var(--accent); font-weight: 800; text-transform: uppercase; font-size: 11px; letter-spacing: 0.5px; }

        .hidden { display: none !important; }
        /* Helper for mobile nav hiding */
        .nav-hidden { display: none !important; }
        
        input[type="color"] { position:absolute; opacity:0; pointer-events:none; }

        /* =========================================
           MOBILE / TABLET ADAPTATIONS (< 1024px)
           ========================================= */
        @media (max-width: 1023px) {
            .top-nav { padding: 0 15px; }
            .brand-name { font-size: 18px; }
            .mobile-header-actions { display: block; }
            
            /* DRAWER PANELS */
            .glass-panel {
                position: fixed; top: auto; bottom: 85px; /* Above Nav */
                left: 15px; right: 15px; width: auto !important;
                border-radius: 24px;
                max-height: 55vh;
                transform: translateY(150%);
                transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
                z-index: 100;
                padding: 20px;
                border: 2px solid white;
                box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            }
            .glass-panel.active { transform: translateY(0); }

            /* Headers inside drawers are hidden, used top bar instead */
            #left-panel .header, #right-panel .header { display: none; }
            #right-panel .mode-switch-container { display: none; }

            /* Floating Camera Buttons */
            .mobile-cam-overlay {
                display: flex; flex-direction: column; gap: 10px;
                position: fixed; top: 80px; right: 15px; z-index: 40;
            }
            .mob-cam-btn {
                width: 40px; height: 40px; border-radius: 50%;
                background: rgba(30, 41, 59, 0.8); color: white;
                border: 2px solid rgba(255,255,255,0.2);
                backdrop-filter: blur(5px); display: flex; align-items: center; justify-content: center;
                font-size: 18px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            }

            /* Floating Dock Nav */
            .mobile-bottom-nav {
                display: flex; justify-content: space-around;
                position: fixed; bottom: 20px; left: 20px; right: 20px;
                background: white; padding: 12px;
                border-radius: 24px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.1), 0 4px 10px rgba(0,0,0,0.05);
                z-index: 200;
                border: 1px solid rgba(255,255,255,0.5);
            }
            .nav-item {
                display: flex; flex-direction: column; align-items: center;
                background: none; border: none; font-family: 'Fredoka';
                color: var(--text-light); font-size: 10px; font-weight: 700; gap: 4px;
                width: 50px; cursor: pointer; transition: transform 0.2s;
            }
            .nav-item.active { color: var(--primary); transform: translateY(-5px); }
            .nav-icon { font-size: 24px; }
            
            /* Card Visibility Logic */
            .card { display: none; }
            .card.mobile-visible { display: block; animation: fadeUp 0.3s ease; }
            @keyframes fadeUp { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }
            
            .info-hud { display: none; } /* Hide HUD on mobile to save space */
        }

        @media (min-width: 1024px) {
            .mobile-bottom-nav, .mobile-cam-overlay { display: none !important; }
            .card { display: block !important; }
            .mobile-header-actions { display: none !important; }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- UNIVERSAL TOP BAR -->
    <nav class="top-nav">
        <div class="brand-container">
            <div class="brand-logo">üöÄ</div>
            <span class="brand-name">FabKids 3D Studio</span>
        </div>
        <!-- Mobile Mode Switcher (Hidden on Desktop) -->
        <div class="mobile-header-actions">
            <div class="mode-switch-container" style="margin:0;">
                <button id="btnEditModeMobile" class="mode-btn active">‚úèÔ∏è EDIT</button>
                <button id="btnViewModeMobile" class="mode-btn">üëÄ VIEW</button>
            </div>
        </div>
    </nav>

    <!-- MOBILE FLOATING CAMERA -->
    <div class="mobile-cam-overlay">
        <button id="mobResetCam" class="mob-cam-btn">üè†</button>
        <button id="mobZoomIn" class="mob-cam-btn">‚ûï</button>
        <button id="mobZoomOut" class="mob-cam-btn">‚ûñ</button>
    </div>

    <!-- LEFT PANEL: WORLD -->
    <div id="left-panel" class="glass-panel">
        <div class="header"><h2>üåç World & Camera</h2></div>

        <div class="card" id="card-world">
            <div class="card-title">üìè Map Size</div>
            <div class="grid-select-row">
                <div id="sizeSmallBtn" class="grid-option"><div class="grid-preview"></div><span class="grid-label">Small</span></div>
                <div id="sizeMedBtn" class="grid-option active"><div class="grid-preview"></div><span class="grid-label">Medium</span></div>
                <div id="sizeBigBtn" class="grid-option"><div class="grid-preview"></div><span class="grid-label">Big</span></div>
            </div>
            
            <div class="action-group" style="margin-top:15px;">
                <button id="exportBtn" class="hero-btn btn-save"><span>üíæ</span> SAVE WORLD</button>
                <button id="clearBtn" class="hero-btn btn-clear"><span>üóëÔ∏è</span> CLEAR ALL</button>
            </div>
        </div>

        <div class="card" id="card-camera">
            <div class="card-title">üéÆ Controls</div>
            <div class="cam-pad">
                <div class="cam-top-row">
                    <button id="rotLeftBtn" class="btn-circle" title="Turn Left">‚Ü∫</button>
                    <button id="resetCamBtn" class="btn-home" title="Reset View">RESET</button>
                    <button id="rotRightBtn" class="btn-circle" title="Turn Right">‚Üª</button>
                </div>
                <div class="zoom-rocker">
                    <button id="zoomOutBtn" class="rocker-side">‚ûñ Out</button>
                    <button id="zoomInBtn" class="rocker-side">‚ûï In</button>
                </div>
            </div>
        </div>
    </div>

    <!-- RIGHT PANEL: BUILDER -->
    <div id="right-panel" class="glass-panel">
        <div class="header"><h1>üèóÔ∏è Builder</h1></div>

        <!-- Desktop Mode Switcher (Hidden on Mobile) -->
        <div class="mode-switch-container">
            <button id="btnEditMode" class="mode-btn active">‚úèÔ∏è EDIT</button>
            <button id="btnViewMode" class="mode-btn">üëÄ VIEW</button>
        </div>

        <div id="editControls">
            <!-- Shapes -->
            <div class="card" id="card-shapes">
                <div class="card-title">Shapes</div>
                <div class="shape-grid">
                    <button id="shapePointBtn" class="shape-btn active"><span class="shape-icon">‚ñ™Ô∏è</span> Single</button>
                    <button id="shapeLineBtn" class="shape-btn"><span class="shape-icon">‚ûñ</span> Line</button>
                    <button id="shapeSquareBtn" class="shape-btn"><span class="shape-icon">‚¨õ</span> Square</button>
                    <button id="shapeRectBtn" class="shape-btn"><span class="shape-icon">‚ñ≠</span> Rect</button>
                    <button id="shapeCubeBtn" class="shape-btn"><span class="shape-icon">üßä</span> Cube</button>
                    <button id="shapeBoxBtn" class="shape-btn"><span class="shape-icon">üì¶</span> Box</button>
                </div>
                
                <div id="shapeControls">
                    <div id="mathDisplay" class="math-display">1 block</div>
                    <div id="lineDirContainer" style="display:none; justify-content:center; gap:5px; margin-bottom:10px;">
                        <button id="lineAxisX" class="tool-btn active" style="padding:6px; font-size:12px;">‚ÜîÔ∏è X</button>
                        <button id="lineAxisZ" class="tool-btn" style="padding:6px; font-size:12px;">‚ÜïÔ∏è Z</button>
                        <button id="lineAxisY" class="tool-btn" style="padding:6px; font-size:12px;">‚¨ÜÔ∏è Y</button>
                    </div>

                    <div class="slider-row" id="sliderXContainer" style="display:none;">
                        <span class="slider-label lbl-x" id="labelX">Size</span>
                        <button class="slider-btn" id="sXDec">-</button>
                        <input type="range" class="shape-range" id="sliderX" min="2" max="10" value="3">
                        <button class="slider-btn" id="sXInc">+</button>
                    </div>
                    <div class="slider-row" id="sliderZContainer" style="display:none;">
                        <span class="slider-label lbl-z">Depth</span>
                        <button class="slider-btn" id="sZDec">-</button>
                        <input type="range" class="shape-range" id="sliderZ" min="2" max="10" value="3">
                        <button class="slider-btn" id="sZInc">+</button>
                    </div>
                    <div class="slider-row" id="sliderYContainer" style="display:none;">
                        <span class="slider-label lbl-y">Height</span>
                        <button class="slider-btn" id="sYDec">-</button>
                        <input type="range" class="shape-range" id="sliderY" min="2" max="10" value="3">
                        <button class="slider-btn" id="sYInc">+</button>
                    </div>
                </div>
            </div>

            <!-- Tools -->
            <div class="card" id="card-tools">
                <div class="card-title">Tools</div>
                <div class="row">
                    <button id="eraserBtn" class="tool-btn"><span>üßπ</span> Eraser</button>
                    <button id="mirrorXBtn" class="tool-btn"><span>‚ÜîÔ∏è</span> X</button>
                    <button id="mirrorZBtn" class="tool-btn"><span>‚ÜïÔ∏è</span> Z</button>
                </div>
                
                <div class="layer-controls-box">
                    <div class="layer-header">
                        <div class="layer-title-group">
                            <span class="layer-text">Level</span>
                            <span id="layerVal" class="layer-badge">0</span>
                        </div>
                        <label class="ghost-toggle">
                            <input type="checkbox" id="ghostModeCheck" checked> Ghost
                        </label>
                    </div>
                    <div class="layer-slider-row">
                        <button class="layer-btn" id="layerDownBtn">‚ñº</button>
                        <input type="range" id="layerSlider" class="layer-range" min="0" max="20" value="0">
                        <button class="layer-btn" id="layerUpBtn">‚ñ≤</button>
                    </div>
                </div>
            </div>

            <!-- Palette -->
            <div class="card" id="card-palette">
                <div class="card-title">Palette</div>
                <div class="palette-box">
                    <div class="color-grid" id="paletteGrid"></div>
                </div>
                <input type="color" id="hiddenColorInput" value="#4D96FF">
            </div>
        </div>

        <!-- View Mode -->
        <div id="viewControls" class="hidden">
            <div class="card" id="card-inspect" style="background:#F0FFF4; border-color:#C6F6D5;">
                <div class="card-title" style="color:#2F855A;">üîç Inspection</div>
                <div class="layer-controls-box" style="background:#F0FFF4; border-color:#C6F6D5;">
                    <div class="layer-header">
                        <div class="layer-title-group">
                            <span class="layer-text" style="color:#2F855A">Level</span>
                            <span id="viewLayerVal" class="layer-badge" style="background:#48BB78">All</span>
                        </div>
                        <label class="ghost-toggle">
                            <input type="checkbox" id="viewLayerToggle"> Slice
                        </label>
                    </div>
                    <div class="layer-slider-row">
                        <button class="layer-btn" id="viewLayerDownBtn" style="color:#2F855A">‚ñº</button>
                        <input type="range" id="viewLayerSlider" class="layer-range" min="0" max="20" value="0" disabled style="background:#C6F6D5">
                        <button class="layer-btn" id="viewLayerUpBtn" style="color:#2F855A">‚ñ≤</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MOBILE BOTTOM DOCK -->
    <div class="mobile-bottom-nav">
        <!-- Edit Mode Buttons -->
        <button id="nav-shapes" class="nav-item" onclick="activateMobileTab('card-shapes')"><span class="nav-icon">üî∑</span> Shapes</button>
        <button id="nav-tools" class="nav-item" onclick="activateMobileTab('card-tools')"><span class="nav-icon">üõ†Ô∏è</span> Tools</button>
        <button id="nav-colors" class="nav-item" onclick="activateMobileTab('card-palette')"><span class="nav-icon">üé®</span> Colors</button>
        
        <!-- View Mode Button (Hidden by default) -->
        <button id="nav-inspect" class="nav-item nav-hidden" onclick="activateMobileTab('card-inspect')"><span class="nav-icon">üîç</span> Inspect</button>
        
        <!-- World Always visible -->
        <button id="nav-world" class="nav-item" onclick="activateMobileTab('card-world')"><span class="nav-icon">üåç</span> World</button>
    </div>

    <!-- HUD INSTRUCTIONS -->
    <div class="info-hud" id="instructions">
        <span id="instrEdit">
            <span class="info-key">TAP</span> Place/Delete<br>
            <span class="info-key">DRAG</span> Spin Camera<br>
            <span class="info-key">SHIFT+TAP</span> Quick Delete
        </span>
        <span id="instrView" class="hidden">
            <span class="info-key">DRAG</span> Spin Camera<br>
            <span class="info-key">SCROLL</span> Zoom In/Out<br>
            Protected Mode (No Edits)
        </span>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';

        // --- MOBILE NAV LOGIC ---
        let activeMobileTab = null;

        window.activateMobileTab = function(cardId) {
            const isLeft = (cardId === 'card-world' || cardId === 'card-camera');
            const targetPanel = isLeft ? document.getElementById('left-panel') : document.getElementById('right-panel');
            const otherPanel = isLeft ? document.getElementById('right-panel') : document.getElementById('left-panel');
            
            // Map card IDs to nav buttons
            const navMap = {
                'card-shapes': 'nav-shapes', 
                'card-tools': 'nav-tools', 
                'card-palette': 'nav-colors', 
                'card-world': 'nav-world',
                'card-inspect': 'nav-inspect'
            };

            if (activeMobileTab === cardId) {
                closeDrawers();
                return;
            }

            otherPanel.classList.remove('active');
            document.querySelectorAll('.nav-item').forEach(b => b.classList.remove('active'));

            if(window.innerWidth < 1024) {
                targetPanel.classList.add('active');
                document.querySelectorAll('.card').forEach(c => c.classList.remove('mobile-visible'));
                document.getElementById(cardId).classList.add('mobile-visible');
                
                document.getElementById(navMap[cardId]).classList.add('active');
                activeMobileTab = cardId;
            }
        };

        window.closeDrawers = function() {
             document.getElementById('left-panel').classList.remove('active');
             document.getElementById('right-panel').classList.remove('active');
             document.querySelectorAll('.nav-item').forEach(b => b.classList.remove('active'));
             activeMobileTab = null;
        }

        document.addEventListener('pointerdown', (e) => {
            if(window.innerWidth < 1024) {
                if(e.target.closest('#canvas-container')) {
                    closeDrawers();
                }
            }
        });

        const syncMode = (mode) => {
            const btns = ['btnEditMode', 'btnViewMode', 'btnEditModeMobile', 'btnViewModeMobile'];
            btns.forEach(id => {
                const el = document.getElementById(id); if(el) el.classList.remove('active');
            });
            if(mode === 'edit') {
                document.getElementById('btnEditMode').classList.add('active');
                document.getElementById('btnEditModeMobile').classList.add('active');
            } else {
                document.getElementById('btnViewMode').classList.add('active');
                document.getElementById('btnViewModeMobile').classList.add('active');
            }
            setAppMode(mode);
        }

        // --- THREE.JS LOGIC ---
        let camera, scene, renderer, controls;
        let plane, gridHelper, axisHelperX, axisHelperZ;
        let raycaster, pointer;
        let appMode = 'edit'; 
        let isShiftDown = false, isEraserMode = false, isLayerMode = true, isGhostMode = true; 
        let isMirrorX = false, isMirrorZ = false;
        let activeShape = 'point', dimX = 3, dimY = 3, dimZ = 3, lineAxis = 'x';
        let currentLayer = 0, currentColor = "#4D96FF"; 
        const mouseStart = new THREE.Vector2();
        let mainCursor;
        const cursors = []; 
        const voxelGroup = new THREE.Group();
        const objects = []; 
        let gridSizeBlocks = 20; 
        const blockSize = 10;     
        const presetColors = ["#ff4d4d", "#ff9f43", "#feca57", "#ff9ff3", "#f368e0", "#00d2d3", "#48dbfb", "#54a0ff", "#2e86de", "#5f27cd", "#1dd1a1", "#10ac84", "#c8d6e5", "#8395a7", "#576574", "#ffffff", "#dfe4ea", "#a4b0be", "#747d8c", "#2f3542", "#800080", "#ff7f50", "#008080", "#3d3d3d"];

        init(); animate();

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0xdbe9f4);
            scene.add(voxelGroup);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 10000);
            updateCameraPosition();
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping=true; controls.dampingFactor=0.05;
            controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6); dirLight.position.set(100,200,100); scene.add(dirLight);
            const fillLight = new THREE.DirectionalLight(0xb0d5ff, 0.4); fillLight.position.set(-100,50,-100); scene.add(fillLight);
            raycaster = new THREE.Raycaster(); pointer = new THREE.Vector2();
            generateGridEnvironment(); setupColorPalette(); setupEventListeners(); syncMode('edit');
        }

        function setAppMode(mode) {
            appMode = mode;
            const editCtrls = document.getElementById('editControls');
            const viewCtrls = document.getElementById('viewControls');
            
            // Elements for Mobile Nav Toggling
            const navShapes = document.getElementById('nav-shapes');
            const navTools = document.getElementById('nav-tools');
            const navColors = document.getElementById('nav-colors');
            const navInspect = document.getElementById('nav-inspect');

            if (mode === 'edit') {
                // Desktop UI
                editCtrls.classList.remove('hidden'); viewCtrls.classList.add('hidden');
                // Mobile Nav
                navShapes.classList.remove('nav-hidden');
                navTools.classList.remove('nav-hidden');
                navColors.classList.remove('nav-hidden');
                navInspect.classList.add('nav-hidden');
                
                isLayerMode = true; 
            } else {
                // Desktop UI
                editCtrls.classList.add('hidden'); viewCtrls.classList.remove('hidden');
                // Mobile Nav
                navShapes.classList.add('nav-hidden');
                navTools.classList.add('nav-hidden');
                navColors.classList.add('nav-hidden');
                navInspect.classList.remove('nav-hidden');

                isLayerMode = false;
                document.getElementById('viewLayerToggle').checked = false;
                document.getElementById('viewLayerSlider').disabled = true;
                
                if(window.innerWidth < 1024) closeDrawers();
            }
            updateLayerState();
        }

        function setupColorPalette() {
            const grid = document.getElementById('paletteGrid');
            const hiddenInput = document.getElementById('hiddenColorInput');
            presetColors.forEach(color => {
                const bubble = document.createElement('div'); bubble.className = 'swatch';
                bubble.style.backgroundColor = color;
                bubble.addEventListener('click', () => selectColor(color, bubble));
                grid.appendChild(bubble);
            });
            const rainbowBubble = document.createElement('div');
            rainbowBubble.className = 'swatch rainbow';
            rainbowBubble.addEventListener('click', () => hiddenInput.click());
            grid.appendChild(rainbowBubble);
            selectColor(presetColors[7], grid.children[7]);
            hiddenInput.addEventListener('input', (e) => {
                Array.from(grid.children).forEach(b => b.classList.remove('active'));
                rainbowBubble.classList.add('active'); updateCurrentColor(e.target.value);
            });
        }

        function selectColor(hex, bubbleElement) {
            const grid = document.getElementById('paletteGrid');
            Array.from(grid.children).forEach(b => b.classList.remove('active'));
            if(bubbleElement) bubbleElement.classList.add('active');
            updateCurrentColor(hex);
            
            // UX: Auto-close on mobile when picking color
            if(window.innerWidth < 1024) closeDrawers();
        }

        function updateCurrentColor(hex) {
            currentColor = hex; document.getElementById('hiddenColorInput').value = hex;
            if(!isEraserMode && !isShiftDown) updateCursorColor(currentColor);
        }

        function updateCursorColor(col) {
            if(mainCursor) mainCursor.material.color.set(col);
            cursors.forEach(c => c.material.color.set(col));
        }

        function generateGridEnvironment() {
            if (gridHelper) scene.remove(gridHelper);
            if (plane) { scene.remove(plane); objects.splice(objects.indexOf(plane), 1); }
            if (axisHelperX) scene.remove(axisHelperX); if (axisHelperZ) scene.remove(axisHelperZ);
            if(mainCursor) scene.remove(mainCursor); cursors.forEach(c => scene.remove(c)); cursors.length = 0;

            const totalSize = gridSizeBlocks * blockSize;
            gridHelper = new THREE.GridHelper(totalSize, gridSizeBlocks, 0x88CCFF, 0xFFFFFF); scene.add(gridHelper);
            const geometryX = new THREE.BoxGeometry(totalSize, 1, 1);
            const materialX = new THREE.MeshBasicMaterial({ color: 0xFF0000, opacity: 0.3, transparent: true });
            axisHelperX = new THREE.Mesh(geometryX, materialX); axisHelperX.visible = isMirrorX; scene.add(axisHelperX);
            const geometryZ = new THREE.BoxGeometry(1, 1, totalSize);
            const materialZ = new THREE.MeshBasicMaterial({ color: 0x0000FF, opacity: 0.3, transparent: true });
            axisHelperZ = new THREE.Mesh(geometryZ, materialZ); axisHelperZ.visible = isMirrorZ; scene.add(axisHelperZ);
            const planeGeo = new THREE.PlaneGeometry(totalSize, totalSize);
            planeGeo.rotateX(-Math.PI / 2);
            plane = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ visible: false }));
            scene.add(plane); objects.push(plane);
            createCursors(); updateLayerState();
        }

        function getShapeDimensions() {
            let w = 1, h = 1, d = 1;
            if (activeShape === 'point') { w=1; h=1; d=1; }
            else if (activeShape === 'line') {
                if(lineAxis === 'x') { w=dimX; h=1; d=1; }
                else if(lineAxis === 'z') { w=1; h=1; d=dimX; }
                else if(lineAxis === 'y') { w=1; h=dimX; d=1; }
            }
            else if (activeShape === 'square') { w=dimX; h=1; d=dimX; } 
            else if (activeShape === 'rect')   { w=dimX; h=1; d=dimZ; }
            else if (activeShape === 'cube')   { w=dimX; h=dimX; d=dimX; }
            else if (activeShape === 'box')    { w=dimX; h=dimY; d=dimZ; }
            return { w, h, d };
        }

        function createCursors() {
            if(mainCursor) scene.remove(mainCursor); cursors.forEach(c => scene.remove(c)); cursors.length = 0;
            const dims = getShapeDimensions();
            const geo = new THREE.BoxGeometry(dims.w * blockSize, dims.h * blockSize, dims.d * blockSize);
            const cursorMat = new THREE.MeshBasicMaterial({ color: currentColor, opacity: 0.5, transparent: true });
            mainCursor = new THREE.Mesh(geo, cursorMat); scene.add(mainCursor);
            for(let i=0; i<3; i++) {
                const g = new THREE.Mesh(geo, cursorMat.clone());
                g.visible = false; scene.add(g); cursors.push(g);
            }
        }

        function updateMathDisplay() {
            const el = document.getElementById('mathDisplay');
            if(activeShape === 'point') el.innerText = "Single Block";
            else if(activeShape === 'line') el.innerText = `Line (${lineAxis.toUpperCase()}): ${dimX} blocks`;
            else if(activeShape === 'square') el.innerText = `Square: ${dimX} x ${dimX} = ${dimX*dimX}`;
            else if(activeShape === 'rect') el.innerText = `Rect: ${dimX} x ${dimZ} = ${dimX*dimZ} blocks`;
            else if(activeShape === 'cube') el.innerText = `Cube: ${dimX} x ${dimX} x ${dimX} = ${dimX*dimX*dimX}`;
            else if(activeShape === 'box')  el.innerText = `Box: ${dimX} x ${dimZ} x ${dimY} = ${dimX*dimY*dimZ} blocks`;
        }

        function onPointerMove(event) {
            if(appMode === 'view') { mainCursor.visible = false; cursors.forEach(c => c.visible = false); return; }
            pointer.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(objects, false);
            mainCursor.visible = false; cursors.forEach(c => c.visible = false);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const isDeleteAction = (isEraserMode || isShiftDown);
                let pos = new THREE.Vector3();
                if (isDeleteAction && intersect.object !== plane && activeShape === 'point') {
                    pos.copy(intersect.object.position);
                } else {
                    const p = intersect.point.clone().add(intersect.face.normal);
                    pos.x = Math.floor(p.x / blockSize) * blockSize + blockSize/2;
                    pos.z = Math.floor(p.z / blockSize) * blockSize + blockSize/2;
                    pos.y = Math.floor(p.y / blockSize) * blockSize + blockSize/2;
                }

                const dims = getShapeDimensions();
                if (isLayerMode || activeShape !== 'point') {
                    const floorY = currentLayer * blockSize;
                    if (activeShape === 'point') {
                        if (!isDeleteAction || intersect.object === plane) pos.y = floorY + blockSize/2;
                    } else {
                        pos.y = floorY + (dims.h * blockSize / 2);
                    }
                }

                let visualPos = pos.clone();
                if (activeShape !== 'point') {
                    if (dims.w % 2 === 0) visualPos.x += blockSize / 2;
                    if (dims.d % 2 === 0) visualPos.z += blockSize / 2;
                }

                mainCursor.visible = true; mainCursor.position.copy(visualPos);
                const mirrorPos = getMirrorPositions(mainCursor.position);
                mirrorPos.forEach((mPos, index) => {
                    if (index < cursors.length) { cursors[index].visible = true; cursors[index].position.copy(mPos); }
                });
            }
        }

        function performAction(cursorPos, isDelete) {
            const dims = getShapeDimensions();
            const totalW = dims.w * blockSize; const totalH = dims.h * blockSize; const totalD = dims.d * blockSize;
            const startX = cursorPos.x - (totalW / 2); const startZ = cursorPos.z - (totalD / 2); const startY = cursorPos.y - (totalH / 2);

            for(let x=0; x<dims.w; x++) {
                for(let y=0; y<dims.h; y++) {
                    for(let z=0; z<dims.d; z++) {
                        const bx = startX + (x * blockSize) + (blockSize/2);
                        const by = startY + (y * blockSize) + (blockSize/2);
                        const bz = startZ + (z * blockSize) + (blockSize/2);
                        const gx = Math.floor(bx/blockSize)*blockSize + blockSize/2;
                        const gy = Math.floor(by/blockSize)*blockSize + blockSize/2;
                        const gz = Math.floor(bz/blockSize)*blockSize + blockSize/2;
                        if (isDelete) deleteVoxelAt(new THREE.Vector3(gx, gy, gz)); else placeVoxelAt(gx, gy, gz);
                    }
                }
            }
        }

        function placeVoxelAt(x, y, z) {
            const pos = new THREE.Vector3(x, y, z);
            for(let block of voxelGroup.children) if(block.position.equals(pos)) return; 
            const voxel = new THREE.Mesh(new THREE.BoxGeometry(blockSize, blockSize, blockSize), new THREE.MeshStandardMaterial({ color: currentColor, roughness: 0.4, metalness: 0.05 }));
            voxel.position.copy(pos); scene.add(voxel); voxelGroup.add(voxel); objects.push(voxel);
        }
        function deleteVoxelAt(pos) {
            const target = voxelGroup.children.find(b => b.position.distanceTo(pos) < 0.1);
            if(target) { scene.remove(target); voxelGroup.remove(target); objects.splice(objects.indexOf(target), 1); }
        }
        function onPointerUp(event) {
            if(event.button !== 0 || appMode === 'view') return;
            if(mouseStart.distanceTo(new THREE.Vector2(event.clientX, event.clientY)) > 10) return;
            if(event.target.closest('.glass-panel') || event.target.closest('.mobile-bottom-nav') || event.target.closest('.mobile-top-bar') || event.target.closest('.mobile-cam-overlay')) return;
            
            if (!mainCursor.visible) return;
            const isDelete = (isEraserMode || isShiftDown);
            const targetPos = mainCursor.position.clone();
            performAction(targetPos, isDelete);
            getMirrorPositions(targetPos).forEach(mPos => performAction(mPos, isDelete));
            if(isLayerMode && !isDelete) updateLayerState(); 
        }
        function onPointerDown(event) { if(event.button===0) mouseStart.set(event.clientX, event.clientY); }
        function getMirrorPositions(basePos) {
            const positions = [];
            if (isMirrorX) positions.push(new THREE.Vector3(-basePos.x, basePos.y, basePos.z));
            if (isMirrorZ) positions.push(new THREE.Vector3(basePos.x, basePos.y, -basePos.z));
            if (isMirrorX && isMirrorZ) positions.push(new THREE.Vector3(-basePos.x, basePos.y, -basePos.z));
            return positions.filter(p => !p.equals(basePos));
        }
        function updateLayerState() {
            document.getElementById('layerSlider').value = currentLayer;
            document.getElementById('viewLayerSlider').value = currentLayer;
            document.getElementById('layerVal').innerText = currentLayer;
            document.getElementById('viewLayerVal').innerText = (appMode==='view' && !isLayerMode) ? "All" : currentLayer;
            
            const layerHeight = currentLayer * blockSize;
            if (isLayerMode) {
                gridHelper.position.y = layerHeight; plane.position.y = layerHeight;
                axisHelperX.position.y = layerHeight; axisHelperZ.position.y = layerHeight;
                voxelGroup.children.forEach(b => {
                    const idx = Math.floor((b.position.y - blockSize/2 + 0.1) / blockSize);
                    if (idx > currentLayer) { b.visible = isGhostMode; if(isGhostMode){b.material.transparent=true; b.material.opacity=0.1; b.material.depthWrite=false;} }
                    else if (idx < currentLayer) { b.visible=true; b.material.transparent=true; b.material.opacity=0.3; b.material.depthWrite=true; }
                    else { b.visible=true; b.material.transparent=false; b.material.opacity=1.0; b.material.depthWrite=true; }
                });
            } else {
                gridHelper.position.y=0; plane.position.y=0; axisHelperX.position.y=0; axisHelperZ.position.y=0;
                voxelGroup.children.forEach(b => { b.visible=true; b.material.transparent=false; b.material.opacity=1.0; b.material.depthWrite=true; });
            }
        }
        function updateCameraPosition() {
            const d = (gridSizeBlocks * blockSize) * 1.5; camera.position.set(d, d*0.8, d); if(controls) {controls.target.set(0,0,0); controls.update();}
        }
        function rotateCam(a) { const x=camera.position.x; const z=camera.position.z; camera.position.x = x*Math.cos(a)-z*Math.sin(a); camera.position.z = x*Math.sin(a)+z*Math.cos(a); camera.lookAt(controls.target); }
        function zoomCam(a) { const d=new THREE.Vector3(); camera.getWorldDirection(d); camera.position.addScaledVector(d, a); }
        function changeLayer(d) { if(isLayerMode && currentLayer+d>=0 && currentLayer+d<=20) { currentLayer+=d; updateLayerState(); } }
        function clearAll() { while(voxelGroup.children.length>0){ const b=voxelGroup.children[0]; voxelGroup.remove(b); scene.remove(b); } objects.length=0; objects.push(plane); }

        // --- NEW EXPORT LOGIC FOR MOBILE EMAIL ---
        async function exportObj() { 
            if(voxelGroup.children.length===0) return alert("Build something first!");
            
            // Backup visualization states
            const bak=[]; 
            voxelGroup.children.forEach(b=>{ 
                bak.push({v:b.visible, t:b.material.transparent, o:b.material.opacity}); 
                b.visible=true; b.material.transparent=false; b.material.opacity=1.0; 
            });

            // Generate Content
            const res = new OBJExporter().parse(voxelGroup);
            
            // Restore visualization
            voxelGroup.children.forEach((b,i)=>{ 
                b.visible=bak[i].v; b.material.transparent=bak[i].t; b.material.opacity=bak[i].o; 
            });

            // Mobile Share Logic
            const file = new File([res], "MyFabKidsWorld.obj", { type: "text/plain" });
            if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                try {
                    await navigator.share({
                        files: [file],
                        title: 'My FabKids 3D World',
                        text: 'Here is the 3D model I built with FabKids Studio!'
                    });
                    return; // Success, skip download
                } catch (error) {
                    console.log('Share canceled/failed', error);
                }
            }

            // Desktop Fallback
            const blob=new Blob([res],{type:'text/plain'}); 
            const link=document.createElement('a'); 
            link.href=URL.createObjectURL(blob); 
            link.download='MyCreation.obj'; 
            link.click();
        }

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }

        function setupEventListeners() {
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('pointerup', onPointerUp);
            document.addEventListener('keydown', e => { if(e.key==="Shift"){isShiftDown=true; updateRollOverVisuals();} });
            document.addEventListener('keyup', e => { if(e.key==="Shift"){isShiftDown=false; updateRollOverVisuals();} });
            window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

            const setShape = (s, btnId) => {
                activeShape = s;
                document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                document.getElementById(btnId).classList.add('active');
                
                const box = document.getElementById('shapeControls');
                const slX = document.getElementById('sliderXContainer');
                const slY = document.getElementById('sliderYContainer');
                const slZ = document.getElementById('sliderZContainer');
                const lblX = document.getElementById('labelX');
                const lineDir = document.getElementById('lineDirContainer');
                
                if (s === 'point') box.classList.remove('open');
                else {
                    box.classList.add('open');
                    if(!isLayerMode) { isLayerMode=true; document.getElementById('layerModeBtn').classList.add('active'); document.getElementById('layerControls').classList.add('open'); updateLayerState(); }
                }

                lineDir.style.display = (s==='line') ? 'flex' : 'none';
                slX.style.display = (s!=='point') ? 'flex' : 'none';
                slZ.style.display = (s==='rect' || s==='box') ? 'flex' : 'none';
                slY.style.display = (s==='box') ? 'flex' : 'none';

                if (s === 'square' || s === 'cube') {
                    lblX.innerText = "SIZE";
                    dimY = dimX; dimZ = dimX;
                    document.getElementById('sliderZ').value = dimX;
                    document.getElementById('sliderY').value = dimX;
                } else {
                    lblX.innerText = "WIDTH";
                }
                updateMathDisplay(); createCursors();
                
                if(window.innerWidth < 1024) closeDrawers();
            };

            const bindSlider = (id, axis) => {
                const sl = document.getElementById(id);
                const update = (val) => {
                    const v = parseInt(val);
                    if(axis==='x') {
                        dimX = v;
                        if (activeShape === 'square' || activeShape === 'cube') {
                            dimZ = v; dimY = v;
                            document.getElementById('sliderZ').value = v;
                            document.getElementById('sliderY').value = v;
                        }
                    }
                    if(axis==='y') dimY = v;
                    if(axis==='z') dimZ = v;
                    sl.value = val; updateMathDisplay(); createCursors();
                };
                sl.addEventListener('input', e => update(e.target.value));
                const btnPrefix = id.replace('slider','s').replace('Container','');
                document.getElementById(btnPrefix + 'Inc').addEventListener('click', () => { if(parseInt(sl.value)<10) update(parseInt(sl.value)+1); });
                document.getElementById(btnPrefix + 'Dec').addEventListener('click', () => { if(parseInt(sl.value)>2) update(parseInt(sl.value)-1); });
            };
            
            bindSlider('sliderX', 'x'); bindSlider('sliderY', 'y'); bindSlider('sliderZ', 'z');

            document.getElementById('shapePointBtn').addEventListener('click', () => setShape('point', 'shapePointBtn'));
            document.getElementById('shapeLineBtn').addEventListener('click', () => setShape('line', 'shapeLineBtn'));
            document.getElementById('shapeSquareBtn').addEventListener('click', () => setShape('square', 'shapeSquareBtn'));
            document.getElementById('shapeRectBtn').addEventListener('click', () => setShape('rect', 'shapeRectBtn'));
            document.getElementById('shapeCubeBtn').addEventListener('click', () => setShape('cube', 'shapeCubeBtn'));
            document.getElementById('shapeBoxBtn').addEventListener('click', () => setShape('box', 'shapeBoxBtn'));

            const setLineAxis = (ax) => {
                lineAxis = ax;
                document.querySelectorAll('.axis-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('lineAxis'+ax.toUpperCase()).classList.add('active');
                updateMathDisplay(); createCursors();
            };
            document.getElementById('lineAxisX').addEventListener('click', () => setLineAxis('x'));
            document.getElementById('lineAxisZ').addEventListener('click', () => setLineAxis('z'));
            document.getElementById('lineAxisY').addEventListener('click', () => setLineAxis('y'));

            document.getElementById('eraserBtn').addEventListener('click', e => { isEraserMode=!isEraserMode; e.target.classList.toggle('active', isEraserMode); updateRollOverVisuals(); });
            document.getElementById('mirrorXBtn').addEventListener('click', e => { isMirrorX=!isMirrorX; e.target.classList.toggle('active'); axisHelperX.visible=isMirrorX; });
            document.getElementById('mirrorZBtn').addEventListener('click', e => { isMirrorZ=!isMirrorZ; e.target.classList.toggle('active'); axisHelperZ.visible=isMirrorZ; });
            document.getElementById('btnEditMode').addEventListener('click', () => syncMode('edit'));
            document.getElementById('btnViewMode').addEventListener('click', () => syncMode('view'));
            document.getElementById('btnEditModeMobile').addEventListener('click', () => syncMode('edit'));
            document.getElementById('btnViewModeMobile').addEventListener('click', () => syncMode('view'));

            document.getElementById('layerSlider').addEventListener('input', e => { currentLayer=parseInt(e.target.value); updateLayerState(); });
            document.getElementById('layerUpBtn').addEventListener('click', () => changeLayer(1));
            document.getElementById('layerDownBtn').addEventListener('click', () => changeLayer(-1));
            document.getElementById('ghostModeCheck').addEventListener('change', e => { isGhostMode=e.target.checked; updateLayerState(); });
            document.getElementById('viewLayerToggle').addEventListener('change', e => { isLayerMode=e.target.checked; document.getElementById('viewLayerSlider').disabled=!isLayerMode; updateLayerState(); });
            document.getElementById('viewLayerSlider').addEventListener('input', e => { currentLayer=parseInt(e.target.value); updateLayerState(); });
            document.getElementById('viewLayerUpBtn').addEventListener('click', () => changeLayer(1));
            document.getElementById('viewLayerDownBtn').addEventListener('click', () => changeLayer(-1));
            document.getElementById('sizeSmallBtn').addEventListener('click', () => setSize(10, 'sizeSmallBtn'));
            document.getElementById('sizeMedBtn').addEventListener('click', () => setSize(20, 'sizeMedBtn'));
            document.getElementById('sizeBigBtn').addEventListener('click', () => setSize(50, 'sizeBigBtn'));
            document.getElementById('clearBtn').addEventListener('click', () => { if(confirm("Clear?")) clearAll(); });
            document.getElementById('exportBtn').addEventListener('click', exportObj);
            document.getElementById('rotLeftBtn').addEventListener('click', () => rotateCam(Math.PI/2));
            document.getElementById('rotRightBtn').addEventListener('click', () => rotateCam(-Math.PI/2));
            document.getElementById('zoomInBtn').addEventListener('click', () => zoomCam(blockSize*5));
            document.getElementById('zoomOutBtn').addEventListener('click', () => zoomCam(-blockSize*5));
            document.getElementById('resetCamBtn').addEventListener('click', updateCameraPosition);
            document.getElementById('mobResetCam').addEventListener('click', updateCameraPosition);
            document.getElementById('mobZoomIn').addEventListener('click', () => zoomCam(blockSize*5));
            document.getElementById('mobZoomOut').addEventListener('click', () => zoomCam(-blockSize*5));
        }

        function setSize(s, id) { 
            if(confirm("New world?")) { 
                gridSizeBlocks=s; currentLayer=0; 
                document.querySelectorAll('.grid-option').forEach(b=>b.classList.remove('active')); 
                document.getElementById(id).classList.add('active'); 
                clearAll(); generateGridEnvironment(); updateCameraPosition(); 
            } 
        }
    </script>
</body>
</html>